---
title: "Results comparison"
output: html_notebook
---

## Setup

```{r setup, include=FALSE}
require(knitr)
knitr::opts_knit$set(root.dir = file.path(getwd(), '..'))
```

```{r}
# Load required R libraries
library(Biostrings)
library(here)
library(phyloseq)
library(qiime2R)
library(tidyverse)
```

## Read in data

```{r}
# Point to directory containing FASTQs at each stage

dcc.dir <- 
     here('data',
          'Adult-2',
          'prior')

qiime.dir <- 
     here('data',
          'Adult-2',
          'current')
```

```{r}
# Well to sample name mapping for prior data
# Batch 1, prior data
batch1.map <- 
     here('..',
          'onr',
          'data',
          'processed',
          'miniseq',
          '20201128',
          '20201128_sample_sheet.csv') %>% 
     read_csv(skip = 16) %>% 
     select(well = Sample_ID, sample = Name)

head(batch1.map)
```

### Read counts

```{r}
# Read in count files from DCC pipeline: Batch 1
count.fs <- list.files(dcc.dir, 
                       pattern = glob2rx('20201128*.txt'),
                       full.names = TRUE)

# Read them
count.fs <- lapply(count.fs, MButils::parse_counts)

# Bind into shared dataframe
counts.batch1 <- 
     reduce(count.fs, left_join, by = 'sample')

names(counts.batch1) <- c('sample', 
                         'raw', 
                         'adapter_trim',
                         'primer_filter',
                         'primer_trim')

rm(count.fs)
```

```{r}
# Batch 2
count.fs <- list.files(dcc.dir, 
                       pattern = glob2rx('20210105*.txt'),
                       full.names = TRUE)

# Read them
count.fs <- lapply(count.fs, MButils::parse_counts)

# Bind into shared dataframe
counts.batch2 <- 
     reduce(count.fs, left_join, by = 'sample')

names(counts.batch2) <- c('sample', 
                          'raw', 
                          'adapter_trim',
                          'primer_filter',
                          'primer_trim')

rm(count.fs)
```

```{r}
# Bind together
counts.batch1$batch <- '20201128'
counts.batch2$batch <- '20210105'

counts.prior <- 
     bind_rows(counts.batch1,
               counts.batch2)
```


```{bash engine.opts='-l'}
# Extract count information from QIIME2 visualization object
# Unzip the files if not already done
cd "$QIIME_DIR"

for f in *.qzv; do
     unzip $f -d ${f%.qzv}
done
```

```{r}
# Read TSVs
count.fs <- 
     list.files(qiime.dir,
                pattern = 'per-sample-fastq-counts.tsv',
                recursive = TRUE,
                full.names = TRUE)

count.fs <- 
     lapply(count.fs, read_delim) %>% 
     lapply(select, -`reverse sequence count`)

counts.qiime <- reduce(count.fs, left_join, by = 'sample ID')
names(counts.qiime) <- c('sample', 
                         'raw',
                         'adapter_trim',
                         'primer_trim')

rm(count.fs)
```
### Files

#### Sequence tables

Use QIIME2R functions to extract information from QIIME2 artifacts. 

```{r}
qiime.asvtab.1 <- 
     here(qiime.dir,
          'batch1',
          '4_denoised-table.qza') %>% 
     read_qza()

qiime.asvtab.2 <- 
     here(qiime.dir,
          'batch2',
          '4_denoised-table.qza') %>% 
     read_qza()
```

```{r}
qiime.seqs.1 <- 
     here(qiime.dir,
          'batch1',
          '4_denoised-seqs.qza') %>% 
     read_qza()

qiime.seqs.2 <- 
     here(qiime.dir,
          'batch2',
          '4_denoised-seqs.qza') %>% 
     read_qza()
```

```{r}
dcc.asvtab.1 <- 
     here(dcc.dir,
          '20201128_seqtab_nochim.rds') %>% 
     readRDS()

dcc.asvtab.2 <- 
     here(dcc.dir,
          '20210105_seqtab_nochim.rds') %>% 
     readRDS()
```

## Pre-process

```{r}
# Add Undetermined sample to map
batch1.map <- 
     bind_rows(batch1.map,
               data.frame(well = 'Undetermined', 
                          sample = 'Undetermined'))
```

### Make phyloseq object

### Combine read counts
```{r}
# Provenance of read counts
counts.qiime$pipeline <- 'QIIME2'
counts.prior$pipeline <- 'DCC'
```

```{r}
# Combine
reads <- 
     bind_rows(counts.prior,
               counts.qiime)

reads
```


### ASV tables

#### Prior

```{r}
# Rename Batch 1 samples for consistency
dcc.asvtab.1 <- 
     dcc.asvtab.1 %>% 
     data.frame() %>% 
     rownames_to_column(var = 'sample') %>% 
     left_join(batch1.map) %>% 
     select(-sample) %>% 
     column_to_rownames(var = 'well') %>% 
     as.matrix()

dcc.asvtab.1 <- dcc.asvtab.1[sort(row.names(dcc.asvtab.1)), ]

head(row.names(dcc.asvtab.1))
```

```{r}
head(row.names(dcc.asvtab.2))
```

#### Current 

QIIME2 output differs from DCC in two ways
- Features in the ASV table features are a hash instead of a DNA sequence
- The table is organized as features x samples instead of samples x features

```{r}
join_table_seqs <- function(feature_table, sequence_hash){
     # feature_table and sequence_hash are the result of reading in QIIME2
     # artifacts with QIIME2R
     
     # Make dataframe mapping from from hash to ASV
     sequence_hash <- 
          data.frame(asv = sequence_hash$data) %>% 
          rownames_to_column(var = 'hash')
     
     # Substitute hash for ASV in feature table
     feature_table <-
          feature_table$data %>% 
          data.frame() %>% 
          rownames_to_column(var = 'hash') %>% 
          left_join(sequence_hash) %>% 
          column_to_rownames(var = 'asv') %>% 
          select(-hash) 
     
     # Transform rows and columns and repair plate-well names\
     feature_table <- t(feature_table) 
     
     # Repair names
     row.names(feature_table) <- gsub(pattern = 'X',
                                      replacement = '',
                                      row.names(feature_table))
     row.names(feature_table) <- gsub(pattern = '\\.',
                                      replacement = '-',
                                      row.names(feature_table))
          
     feature_table
}
```

```{r}
qiime.asvtab.1 <- join_table_seqs(qiime.asvtab.1, qiime.seqs.1)
qiime.asvtab.2 <- join_table_seqs(qiime.asvtab.2, qiime.seqs.2)
```

## Compare
